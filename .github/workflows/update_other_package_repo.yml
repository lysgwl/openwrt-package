name: Update Other Package Repo

#on:
#  schedule:
#    - cron: '*/2 * * * *'     # 每天凌晨运行 (0 0 * * *)

on:
  repository_dispatch:
  workflow_dispatch:
  
env:
  REPO_REMOTE_COND: false   
  
jobs:
  build:   # update build
    runs-on: ubuntu-latest
    
    steps:
    
    - name: Checkout master branch
      uses: actions/checkout@v2
      with:
        ref: master
        
    - name: Set SSH key and known_hosts
      uses: webfactory/ssh-agent@v0.5.3
      with:
        ssh-private-key: ${{ secrets.PERSONAL_SSH_KEY }}   

    - name: Setup git config
      run: |
        git config --global user.name "lysgwl"
        git config --global user.email "lysgwl@163.com"      
        
    - name: Add remote repository
      if: env.REPO_REMOTE_COND == 'true' && !cancelled()
      run: |
        function add_fetch_repo() {
            echo "add remote repository: $2"    
            git remote add $1 https://github.com/$2.git || true
            git fetch $1
        }
        
        add_fetch_repo diskman lisaac/luci-app-diskman
        add_fetch_repo ddns-go sirpdboy/luci-app-ddns-go
        add_fetch_repo OpenAppFilter destan19/OpenAppFilter
        add_fetch_repo poweroff esirplayground/luci-app-poweroff
        add_fetch_repo socat chenmozhijin/luci-app-socat

    - name: Copy repository contents
      if: env.REPO_REMOTE_COND == 'true' && !cancelled()
      run: |
        function copy_repo_contents() {
            local branch=$1             # 分支名
            local remote_alias=$2       # 远程仓库别名
            local local_dir_name=$3     # 本地目录名
            local package_path_rel=$4   # 相对于顶层目录的路径
            
            # 转到Git顶层目录
            pushd $(git rev-parse --show-toplevel)
            
            # 计算相对于Git顶层的目标路径
            local target_path="${package_path_rel}/${local_dir_name}"
            
            # 移除路径开头的"./"
            target_path="${target_path#./}" 
        
            if [ -d "$target_path" ]; then
                echo "Repository ${local_dir_name} already cloned. Pulling updates..."

                pushd "$target_path"
                # 更新远程内容
                git fetch $remote_alias $branch 

                # 硬重置本地分支
                git reset --hard FETCH_HEAD
                popd
            else
                echo "Cloning repository content into the new prefix...$target_path"
                git subtree add --prefix="$target_path" $remote_alias $branch --squash
            fi
            
            popd
        }
        
        # 相对于git顶层目录的路径
        package_path_rel="otherpackage"
        
        # 获取当前的HEAD哈希值
        original_head=$(git rev-parse HEAD)

        copy_repo_contents master diskman luci-app-diskman $package_path_rel
        copy_repo_contents main ddns-go luci-app-ddns-go $package_path_rel
        copy_repo_contents master OpenAppFilter luci-app-OpenAppFilter $package_path_rel
        copy_repo_contents master poweroff luci-app-poweroff $package_path_rel
        copy_repo_contents main socat luci-app-socat $package_path_rel
        
        # 获取新的HEAD哈希值
        new_head=$(git rev-parse HEAD)
        
        # 根据哈希值判断状态
        if [[ "$original_head" != "$new_head" ]]; then
            status="successful"
        else
            status="no_changes"
        fi
        
        echo "repo_status=$status" >> $GITHUB_ENV
        
    - name: Clone and merge repository contents
      if: env.REPO_REMOTE_COND == 'false' && !cancelled()    
      run: |
        function clone_repo_contents() {
            local remote_repo=$1        # 远程仓库URL
            local branch=$2             # 分支名
            local local_dir_name=$3     # 本地目录名
            local package_path_rel=$4   # 相对于顶层目录的路径
            
            # 临时目录，用于克隆远程仓库
            local temp_dir=$(mktemp -d)
            
            # 克隆远程仓库到临时目录
            git clone --depth 1 --branch $branch $remote_repo $temp_dir
            
            if [ $? -eq 0 ]; then
                local target_path="$package_path_rel/$local_dir_name"
                
                if [ -d "$target_path" ]; then
                    echo "Removing old files from $target_path."
                    
                    # 使用:?防止变量为空时删除根目录
                    rm -rf "${target_path:?}"/*  
                else
                    # 如果目标路径不存在，创建目标路径
                    mkdir -p "$target_path"
                fi
                # 创建目标路径
                mkdir -p "$package_path_rel/$local_dir_name"
            
                # 复制克隆的内容到目标路径
                cp -r $temp_dir/* "$package_path_rel/$local_dir_name/"
            fi
            
            # 清理临时目录
            rm -rf $temp_dir
        }
        
        # 相对于git顶层目录的路径
        package_path_rel="otherpackage"
        mkdir -p "$package_path_rel"

        clone_repo_contents https://github.com/lisaac/luci-app-diskman.git master luci-app-diskman $package_path_rel
        clone_repo_contents https://github.com/sirpdboy/luci-app-ddns-go.git main luci-app-ddns-go $package_path_rel
        
    - name: Commit and push repository using SSH
      run: |
        function check_git_commit {
            # 目标目录路径
            local target_path=$1   
            
            # 进入目标目录
            cd "$target_path" || { echo "Error: Unable to change directory to $target_path"; exit 1; }
            echo "test1"
            #
            git add .
            echo "test2"
            git status
            echo "test3"
            
            # 检查git状态
            local has_changes=$(git status --porcelain | grep '^[MADRC]')
            echo "status=$has_changes"
            if [ -n "$has_changes" ]; then
                git commit -m "Auto commit changes"
                git push origin master
            fi
        }
        
        # 相对于git顶层目录的路径
        package_path_rel="otherpackage"
        check_git_commit $package_path_rel
        
    #- name: Push changes repository
    #  uses: ad-m/github-push-action@master
    #  with:
    #    github_token: ${{ secrets.GITHUB_TOKEN }}   # PERSONAL_ACCESS_TOKEN
    #    branch: ${{ github.ref }}    # master
